/**
 * @class Asset
 *
 * An asset object represents a single node in an AssetGraph, but can
 * be used and manipulated on its own outside the graph context.
 */
var path = require('path'),
    EventEmitter = require('events').EventEmitter,
    util = require('util'),
    crypto = require('crypto'),
    _ = require('lodash'),
    urlTools = require('urltools'),
    resolveDataUrl = require('../util/resolveDataUrl'),
    extendWithGettersAndSetters = require('../util/extendWithGettersAndSetters'),
    passError = require('passerror'),
    AssetGraph = require('../'),
    urlEndsWithSlashRegExp = /\/(?:[?#].*)?$/;

/**
 * new Asset(options)
 * ==================
 *
 * Create a new Asset instance.
 *
 * Most of the time it's unnecessary to create asset objects
 * directly. When you need to manipulate assets that already exist on
 * disc or on a web server, the `loadAssets` and `populate` transforms
 * are the easiest way to get the objects created. See the section about
 * transforms below.
 *
 * Note that the Asset base class is only intended to be used to
 * represent assets for which there's no specific subclass.
 *
 * Options:
 *
 *  - `rawSrc`      `Buffer` object containing the raw source of the asset.
 *                  Mandatory unless the `rawSrcProxy` option is provided.
 *  - `rawSrcProxy` Function that provides the raw source of the asset
 *                  to a callback (and optionally a metadata object),
 *                  for example by loading it from disc or fetching it
 *                  via http. Mandatory unless the `rawSrc` option is
 *                  provided.
 *  - `contentType` (optional) The Content-Type (MIME type) of the asset.
 *                  For subclasses of Asset there will be a reasonable
 *                  default. Can also be provided by the `rawSrcProxy`
 *                  in the `metadata` object.
 *  - `url`         (optional) The fully qualified (absolute) url of the
 *                  asset. If not provided, the asset will be considered
 *                  inline. Can also be provided by the `rawSrcProxy`
 *                  in the `metadata' object (think HTTP redirects).
 *  - `extension`   The desired file name extension of the asset. Will
 *                  be extracted from the `url` option if possible, and in
 *                  that case, the `extension` option will be ignored.
 *  - `fileName`    The desired file name of the asset. Will
 *                  be extracted from the `url` option if possible, and in
 *                  that case, the `fileName` option will be ignored.
 *                  Takes precedence over the `extension` config option.
 */
function Asset(config) {
    EventEmitter.call(this);
    if ('lastKnownByteLength' in config) {
        this._lastKnownByteLength = config.lastKnownByteLength;
        delete config.lastKnownByteLength;
    }
    if (config.rawSrc) {
        this._updateRawSrcAndLastKnownByteLength(config.rawSrc);
        delete config.rawSrc;
    }
    if (config.parseTree) {
        this._parseTree = config.parseTree;
        delete config.parseTree;
    }
    if (config.url) {
        this._url = config.url.trim();
        if (!urlEndsWithSlashRegExp.test(this._url)) {
            var pathname = urlTools.parse(this._url).pathname;
            this._extension = path.extname(pathname);
            this._fileName = path.basename(pathname);
        }
        delete config.url;
    } else {
        if ('fileName' in config && !('_fileName' in this)) {
            this._fileName = config.fileName;
            this._extension = path.extname(this._fileName);
        }
        delete config._fileName;
        if ('extension' in config && !('_extension' in this)) {
            this._extension = config.extension;
        }
        delete config.extension;
    }
    if (config.outgoingRelations) {
        this._outgoingRelations = config.outgoingRelations.map(function (outgoingRelation) {
            outgoingRelation.from = this;
            return outgoingRelation;
        }, this);
        delete config.outgoingRelations;
    }
    _.extend(this, config);
    this.id = '' + _.uniqueId();
}

util.inherits(Asset, EventEmitter);

extendWithGettersAndSetters(Asset.prototype, {
    /**
     * asset.isAsset
     * =============
     *
     * {Boolean} Property that's true for all Asset instances. Avoids
     * reliance on the `instanceof` operator.
     *
     * @api public
     */
    isAsset: true,

    isResolved: true,

    /**
     * asset.isExternalizable
     * ======================
     *
     * {Boolean} Whether the asset occurs in a context where it can be
     * made external. If false, the asset will stay inline. Useful for
     * "always inline" assets pointed to by HtmlConditionalComment,
     * HtmlDataBindAttribute, and HtmlKnockoutContainerless
     * relations. Override when creating the asset.
     */
    isExternalizable: true,

    /**
     * asset.contentType
     * =================
     *
     * {String} The Content-Type (MIME type) of the asset.
     *
     * @api public
     */
    contentType: 'application/octet-stream',

    /**
     * asset.defaultExtension (getter)
     * ===============================
     *
     * {String} The default extension for the asset type.
     *
     * @api public
     */
    get defaultExtension() {
        return (this.supportedExtensions && this.supportedExtensions[0]) || '';
    },

    /**
     * asset.parseTree (getter)
     * ========================
     *
     * Some asset classes support inspection and manipulation using a high
     * level interface. If you modify the parse tree, you have to call
     * `asset.markDirty()` so any cached serializations of the asset are
     * invalidated.
     *
     * These are the formats you'll get:
     *
     * `Html` and `Xml`:
     *     jsdom document object (https://github.com/tmpvar/jsdom).
     *
     * `Css`
     *     CSSOM CSSStyleSheet object (https://github.com/NV/CSSOM).
     *
     * `JavaScript`
     *     UglifyJS AST object (https://github.com/mishoo/UglifyJS).
     *
     * `Json`
     *     Regular JavaScript object (the result of JSON.parse on the decoded source).
     *
     * `CacheManifest`
     *     A JavaScript object with a key for each section present in the
     *     manifest (`CACHE`, `NETWORK`, `REMOTE`). The value is an array with
     *     an item for each entry in the section. Refer to the source for
     *     details.
     *
     * @api public
     */

    _isRelationUrl: function (url) {
        return url && !/^\s*$|^#/i.test(url);
    },

    /**
     * asset.load(cb)
     * ==============
     *
     * Makes sure the asset is loaded, then calls the supplied
     * callback. This is Asset's only async method, as soon as it is
     * loaded, everything can happen synchronously.
     *
     * Usually you'll want to use `transforms.loadAssets`, which will
     * handle this automatically.
     *
     * @param {Function} cb The callback to invoke when the asset is loaded.
     * @api public
     */
    load: function (cb) {
        var that = this;
        if (that.isLoaded) {
            setImmediate(cb);
     